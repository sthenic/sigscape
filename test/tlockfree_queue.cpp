#include <thread>
#include <chrono>
#include "thread_safe_queue.h"
#include "lockfree_queue.h"
#include "MPMCQueue.h"

#include "fmt/format.h"
#include "CppUTest/TestHarness.h"

#include <vector>
#include <mutex>
#include <condition_variable>
#include <atomic>
#include <chrono>

template <typename T, size_t CAPACITY>
class NaiveQueue
{
public:
    NaiveQueue()
        : m_queue(CAPACITY)
        , m_tail(0)
        , m_head(0)
        , m_mutex()
        , m_overflow()
        , m_empty()
    {}

    int Start()
    {
        return SCAPE_EOK;
    };

    int Stop()
    {
        return SCAPE_EOK;
    };

    int Write(const T &x, int timeout)
    {
        (void)timeout;
        std::unique_lock<std::mutex> lock(m_mutex);
        m_overflow.wait(lock, [this](){
            return this->m_tail + CAPACITY > this->m_head;
        });

        m_queue[m_head++ & CAPACITY_MASK] = x;
        m_empty.notify_one();
        return SCAPE_EOK;
    }

    int Read(T &value, int timeout)
    {
        (void)timeout;
        std::unique_lock<std::mutex> lock(m_mutex);
        m_empty.wait(lock, [this](){
            return this->m_head > this->m_tail;
        });

        value = m_queue[m_tail++ & CAPACITY_MASK];
        m_overflow.notify_one();
        return SCAPE_EOK;
    }

private:
    static constexpr size_t CAPACITY_MASK = CAPACITY - 1;

    std::vector<T> m_queue;
    size_t m_tail;
    size_t m_head;
    std::mutex m_mutex;
    std::condition_variable m_overflow;
    std::condition_variable m_empty;
};

/* Test parameters */
static const size_t QUEUE_SIZE = 64 * 1024; /* MUST BE POWER OF TWO FOR THE MAST TO WORK*/
static const size_t NOF_CONSUMERS = 1;
static const size_t NOF_PRODUCERS = 1;

/* Number of elements generated by each producer. */
static const int N = QUEUE_SIZE * 64;

/* Producers write MISSED, consumers write CONSUMED but only if the value is MISSED. */
static const uint8_t EMPTY = 0;
static const uint8_t MISSED = 1;
static const uint8_t CONSUMED = 2;
static std::vector<uint8_t> values(N * NOF_PRODUCERS);

/* Atomic variable to stop the readers. */
std::atomic<size_t> n(0);

template <typename T>
static void Producer(size_t offset, T *queue)
{
    /* Write interleaved with the other producers. Store the address in the
       queue for retrieval by the reader. */
    for (auto i = offset; i < N * NOF_PRODUCERS; i += NOF_PRODUCERS)
    {
        values[i] = MISSED;
        while (queue->Write(values.data() + i, -1) != SCAPE_EOK)
            ;
        // printf("Producer %zu wrote values[%zu] = MISSED, stored %p\n", offset, i, values.data() + i);
    }
}

template <typename T>
static void Consumer(T *queue)
{
    /* The consumers are not paired with a producer and run until the target
       number of entries have been consumed. */
    int nof_consumed = 0;
    while (n.fetch_add(1) < N * NOF_PRODUCERS)
    {
        uint8_t *addr;
        while (queue->Read(addr, -1) != SCAPE_EOK)
            ;
        CHECK(addr != NULL);
        // printf("Consumer read address *%p = %u\n", addr, *addr);
        CHECK(*addr == MISSED);
        *addr = CONSUMED;
        ++nof_consumed;
    }
    printf("Thread consumed %d entries.\n", nof_consumed);
}

template <typename T>
class MpmcQueue : public rigtorp::MPMCQueue<T>
{
public:
    MpmcQueue()
        : rigtorp::MPMCQueue<T>(QUEUE_SIZE)
    {}

    int Start()
    {
        return SCAPE_EOK;
    }

    int Stop()
    {
        return SCAPE_EOK;
    }

    int Write(const T &x, int timeout)
    {
        (void)timeout;
        this->push(x);
        // while (!this->try_push(x))
        //     ;
        return SCAPE_EOK;
    }

    int Read(T &value, int timeout)
    {
        (void)timeout;
        this->pop(value);
        // while (!this->try_pop(value))
        //     ;
        return SCAPE_EOK;
    }
};

template <typename T>
static void TestQueue()
{
    printf("\n");
    n.store(0);
    std::memset(values.data(), EMPTY, values.size() * sizeof(values[0]));

    T queue;
    std::vector<std::thread> workers;
    queue.Start();

    for (size_t i = 0; i < NOF_PRODUCERS; ++i)
        workers.emplace_back(&Producer<T>, i, &queue);

    for (size_t i = 0; i < NOF_CONSUMERS; ++i)
        workers.emplace_back(&Consumer<T>, &queue);

    for (auto &worker : workers)
        worker.join();

    /* Check all the values */
    for (size_t i = 0; i < values.size(); ++i)
    {
        switch (values[i])
        {
        case CONSUMED:
            break;

        case EMPTY:
            FAIL(fmt::format("Index {} failed to be produced (producer {})", i, i % NOF_PRODUCERS).c_str());
            break;

        case MISSED:
            FAIL(fmt::format("Index {} failed to be consumed.", i).c_str());
            break;

        default:
            FAIL(fmt::format("Unexpected value {} for index {} (producer {}).", values[i], i, i % NOF_PRODUCERS).c_str());
            break;
        }
    }

    queue.Stop();
}

TEST_GROUP(LockfreeQueue)
{
    std::chrono::system_clock::time_point start;
    std::chrono::system_clock::time_point stop;

    void setup()
    {
        start = std::chrono::high_resolution_clock::now();
    }

    void teardown()
    {
        stop = std::chrono::high_resolution_clock::now();
        const auto delta = stop - start;
        const auto throughput = static_cast<double>(N) / (delta.count() * 1e-9);
        printf("Throughput %.3f M items/s\n", throughput / 1e6);
    }
};

TEST(LockfreeQueue, NaiveQueue)
{
    TestQueue<NaiveQueue<uint8_t *, QUEUE_SIZE>>();
}


TEST(LockfreeQueue, ThreadSafeQueue)
{
    TestQueue<ThreadSafeQueue<uint8_t *>>();
}

TEST(LockfreeQueue, LockfreeQueue)
{
    TestQueue<LockfreeQueue<uint8_t *>>();
}

TEST(LockfreeQueue, MPMCQueue)
{
    TestQueue<MpmcQueue<uint8_t *>>();
}
