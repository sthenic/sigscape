#include <thread>
#include <chrono>
#include "thread_safe_queue.h"

#include "fmt/format.h"
#include "CppUTest/TestHarness.h"

#include <vector>
#include <mutex>
#include <condition_variable>
#include <atomic>

template <typename T, size_t CAPACITY>
class NaiveQueue
{
public:
    NaiveQueue()
        : m_queue(CAPACITY)
        , m_tail(0)
        , m_head(0)
        , m_mutex()
        , m_overflow()
        , m_empty()
    {}

    int Start()
    {
        return SCAPE_EOK;
    };

    int Stop()
    {
        return SCAPE_EOK;
    };

    void Write(const T &x)
    {
        std::unique_lock<std::mutex> lock(m_mutex);
        m_overflow.wait(lock, [this](){
            return this->m_tail + CAPACITY > this->m_head;
        });

        m_queue[m_head++ & CAPACITY_MASK] = x;
        m_empty.notify_one();
    }

    int Read(T &value, int timeout)
    {
        (void)timeout;
        std::unique_lock<std::mutex> lock(m_mutex);
        m_empty.wait(lock, [this](){
            return this->m_head > this->m_tail;
        });

        value = m_queue[m_tail++ & CAPACITY_MASK];
        m_overflow.notify_one();
        return SCAPE_EOK;
    }

private:
    static constexpr size_t CAPACITY_MASK = CAPACITY - 1;

    std::vector<T> m_queue;
    size_t m_tail;
    size_t m_head;
    std::mutex m_mutex;
    std::condition_variable m_overflow;
    std::condition_variable m_empty;
};

TEST_GROUP(LockfreeQueue)
{
    void setup()
    {
    }

    void teardown()
    {
    }
};

/* Test parameters */
static const size_t QUEUE_SIZE = 32 * 1024; /* MUST BE POWER OF TWO FOR THE MAST TO WORK*/
static const size_t NOF_CONSUMERS = 8;
static const size_t NOF_PRODUCERS = 8;

/* Number of elements generated by each producer. */
static const int N = QUEUE_SIZE * 16;

/* Producers write MISSED, consumers write CONSUMED but only if the value is MISSED. */
static const uint8_t EMPTY = 0;
static const uint8_t MISSED = 1;
static const uint8_t CONSUMED = 2;
static std::vector<uint8_t> values(N * NOF_PRODUCERS);

/* Atomic variable to stop the readers. */
std::atomic<size_t> n(0);

template <typename T>
static void Producer(size_t offset, T *queue)
{
    /* Write interleaved with the other producers. Store the address in the
       queue for retrieval by the reader. */
    for (auto i = offset; i < N * NOF_PRODUCERS; i += NOF_PRODUCERS)
    {
        values[i] = MISSED;
        queue->Write(values.data() + i);
        // printf("Producer %zu wrote values[%zu] = MISSED, stored %p\n", offset, i, values.data() + i);
    }
}

template <typename T>
static void Consumer(T *queue)
{
    /* The consumers are not paired with a producer and run until the target
       number of entries have been consumed. */
    while (n.fetch_add(1) < N * NOF_PRODUCERS)
    {
        uint8_t *addr;
        queue->Read(addr, -1);
        CHECK(addr != NULL);
        // printf("Consumer read address *%p = %u\n", addr, *addr);
        CHECK(*addr == MISSED);
        *addr = CONSUMED;
    }
}

template <typename T>
static void TestQueue()
{
    printf("\n");
    n.store(0);
    std::memset(values.data(), EMPTY, values.size() * sizeof(values[0]));

    T queue;
    std::vector<std::thread> workers;
    queue.Start();

    for (size_t i = 0; i < NOF_PRODUCERS; ++i)
        workers.emplace_back(&Producer<T>, i, &queue);

    for (size_t i = 0; i < NOF_CONSUMERS; ++i)
        workers.emplace_back(&Consumer<T>, &queue);

    for (auto &worker : workers)
        worker.join();

    /* Check all the values */
    for (size_t i = 0; i < values.size(); ++i)
    {
        switch (values[i])
        {
        case CONSUMED:
            break;

        case EMPTY:
            FAIL(fmt::format("Index {} failed to be produced (producer {})", i, i % NOF_PRODUCERS).c_str());
            break;

        case MISSED:
            FAIL(fmt::format("Index {} failed to be consumed.", i).c_str());
            break;

        default:
            FAIL(fmt::format("Unexpected value {} for index {} (producer {}).", values[i], i, i % NOF_PRODUCERS).c_str());
            break;
        }
    }

    queue.Stop();
    printf("Joined all threads\n");
}

TEST(LockfreeQueue, NaiveQueue)
{
    TestQueue<NaiveQueue<uint8_t *, QUEUE_SIZE>>();
}


TEST(LockfreeQueue, ThreadSafeQueue)
{
    TestQueue<ThreadSafeQueue<uint8_t *>>();
}
